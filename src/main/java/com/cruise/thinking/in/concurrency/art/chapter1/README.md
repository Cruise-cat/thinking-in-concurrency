## 第一章 并发编程的挑战

并发编程的目的是为了让程序运行得更快，但是并不是启动更多的线程就能让程序最大限度地并发执行。
如果希望通过多线程执行任务让程序运行得更快，会面临非常多的挑战，比如**上下文切换的问题、死锁的问题，以及受限于硬件和软件的资源限制问题**，
本章会介绍几种并发编程的挑战以及解决方案。
    
### 上下文切换

即使是单核处理器也支持多线程执行代码，CPU 通过给每个线程分配 CPU 时间片来实现这个机制。时间片是 CPU 分配给各个线程的时间，因为时间片非常短，
所以 CPU 通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒。

CPU 通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，
可以再加载这个任务的状态。所以**任务从保存到再加载的过程就是一次上下文切换,另外每一次从 WAITTING 到 RUNNABLE 也会进行一次上下文的切换**。这样的切换是会影响多线程的执行效率的。

#### 多线程一定快吗？

下面的代码演示串行和并发执行并累加操作的时间，请分析：下面的代码并发执行一定比串行执行快吗？

[代码示例](MustConcurrencyBeFast.java)

<table>
    <thead>
        <tr>
            <th>循环次数</th>
            <th>串行执行耗时/ms</th>
            <th>并行执行耗时/ms</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1 万</td>
            <td>0</td>
            <td>1</td>
        </tr>
        <tr>
            <td>10 万</td>
            <td>4</td>
            <td>3</td>
        </tr>
        <tr>
            <td>100 万</td>
            <td>5</td>
            <td>5</td>
        </tr>      
        <tr>
            <td>1000 万</td>
            <td>18</td>
            <td>9</td>
        </tr>       
        <tr>
            <td>1 亿</td>
            <td>130</td>
            <td>77</td>
        </tr>                   
    </tbody>
</table>

当并发执行累加操作不超过百万次时，速度会比串行执行累加操作要慢。这是因为**线程有创建和上下文切换的开销**。

#### 如何减少上下文切换
减少上下文切换的方法有**无锁并发编程、CAS 算法、使用最少线程和使用协程**。

- 无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的 ID 按照 Hash 算法取模分段，不同的线程处理不同段的数据。
- CAS 算法。Java 的 Atomic 包使用 CAS 算法来更新数据，不需要加锁。
- 使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。
- 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

### 死锁

下面这段代码会引起死锁，使线程 t1 和线程 t2 互相等待对方释放锁。

[代码示例](DeadLock.java)

这段代码只是演示死锁的场景，在现实中你可能不会写出这样的代码。但是，在一些更为复杂的场景中，你可能会遇到这样的问题，
比如 t1 拿到锁之后，因为一些异常情况没有释放锁。又或者是 t1 拿到一个数据库锁，释放锁的时候抛出了异常，没释放掉。
程序发生死锁是可以感知的，可以通过 jstack 命令 dump 线程信息查看是哪个线程出了问题。

```text
"t2":
        at com.cruise.thinking.in.concurrency.art.chapter1.DeadLock.lambda$main$1(DeadLock.java:35)
        - waiting to lock <0x000000074078d870> (a java.lang.String)
        - locked <0x000000074078d8a0> (a java.lang.String)
        at com.cruise.thinking.in.concurrency.art.chapter1.DeadLock$$Lambda$2/1831932724.run(Unknown Source)
        at java.lang.Thread.run(Thread.java:748)
"t1":
        at com.cruise.thinking.in.concurrency.art.chapter1.DeadLock.lambda$main$0(DeadLock.java:21)
        - waiting to lock <0x000000074078d8a0> (a java.lang.String)
        - locked <0x000000074078d870> (a java.lang.String)
        at com.cruise.thinking.in.concurrency.art.chapter1.DeadLock$$Lambda$1/990368553.run(Unknown Source)
        at java.lang.Thread.run(Thread.java:748)

Found 1 deadlock.
```
避免死锁的几个常见方法。
- 避免一个线程同时获取多个锁。
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
- 尝试使用定时锁，使用 lock.tryLock（timeout） 来替代使用内部锁机制。
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。

### 资源限制的挑战
#### 什么是资源限制
资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。例如，服务器的带宽只有 2Mb/s，某个资源的下载速度是 1Mb/s 每秒，
系统启动 10 个线程下载资源，下载速度不会变成 10Mb/s，所以在进行并发编程时，要考虑这些资源的限制。
硬件资源限制有带宽的上传/下载速度、硬盘读写速度和 CPU 的处理速度。软件资源限制有数据库的连接数和 socket 连接数等。
#### 资源限制引发的问题
在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，
仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。
#### 如何解决资源限制的问题
对于硬件资源限制，可以考虑使用集群并行执行程序。既然单机的资源有限制，那么就让程序在多机上运行。对于软件资源限制，可以考虑使用资源池将资源复用。比如使用连接池将数据库和 Socket 连接复用。
#### 在资源限制情况下进行并发编程
如何在资源限制的情况下，让程序执行得更快呢？方法就是，根据不同的资源限制调整程序的并发度。
### 总结
对于 Java 开发工程师强烈建议多使用 JDK 并发包提供的并发容器和工具类来解决并发问题，因为这些类都已经通过了充分的测试和优化，均可解决了本章提到的几个挑战。
